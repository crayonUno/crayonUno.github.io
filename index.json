[{"content":"How to Elegantly Remove if-else in Your Java Code original link: https://medium.com/@malvin.lok/how-to-elegantly-remove-if-else-in-your-java-code-27b2393544ae\npracticing principles:\nFind a sample article of the same type that you want to improve.\nTranslate it into Chinese.\nLook at the Chinese translation and write it back in English.\nCompare what you wrote with the sample essay, and upgrade your expression.\nPractice in action. Select a relative topic and write in English.\nMy writing Sometimes, that let if-else syntax be full of your code is not a correct way to let your colleagues to understand.\nSometimes, letting your code full of if-else statement is not the most effective way to help your colleagues understand it.\nTherefore, as a beginner, or even you are quite good at your job, still need to let your code more readable and (复杂?).\nThererfore, as a beginner, or even you are quite good at your job, you still need to make your code more readable and clear.\nThe first thing you should have a try is removing if-else statement（syntax） in your code. Here are some suggestions.\nChoice 1: Earlier Early return earlier return is grammatically correct but might be less common.\nassume we have such code below：\nAssume we have the following code:\npublic boolean isValid(String condition) { boolean result; if (condition != null){ if (condition.equals(\u0026#34;hi\u0026#34;) { result = true; } else { result = false; } } else { result= false; } return result; } This is what we usually used to return earlier, remove unnecessary else.\nThis is the kind of code that we generally use to return early, removing the unnecessary else.\npublic boolean isValid(String condition) { if (condition == null) { return false; } if (condition.equals(\u0026#34;hi\u0026#34;) { return true } return false; } This choice usually fits for simple code structure, we can return earlier, remove some of improper if-else\nThis approach is typically suitable for simple code structures; we can return earlier, removing some of the improper if-else statements.\nThis approach is generally only suitable for simple structures and we can return early to get rid of some of the unnecessary if-else.\nChoice 2: Enumeration Assume that we have such a code snippet :\npublic String getLabel(int status) { String label; if (1 == status) { label = \u0026#34;Padding\u0026#34;; } else if (2 == status) { label = \u0026#34;Paid\u0026#34;; } else if (3 == status) { label = \u0026#34;Success\u0026#34;; } else if (4 == status) { label = \u0026#34;Failed\u0026#34;; } return label; } Maybe you should say that there is no one write code like this in 20th century. But actually, code snippet like this is very common.\nPerhaps you could say, no one writes code like this in the 20th century. However, in reality, code snippets like this remain very common.\n** A code snippet like this can be replaced by an Enumeration perfectly, let\u0026rsquo;s define an Enum class at first:\nThis type of code is well-suited for enumeration to solve, let’s define an enumeration first:\n@Getter @AllArgsConstructor public enum StatusLabelEnum { Padding(1, \u0026#34;Padding\u0026#34;), Paid(2, \u0026#34;Paid\u0026#34;), Success(3, \u0026#34;Success\u0026#34;), Failed(4, \u0026#34;Failed\u0026#34;), ; private int status; private String label; public static String getLabelByStatus(int status) { for (StatusLabelEnum labelEnum : StatusLabelEnum.values()) { if (labelEnum.getStatus() == status) { return labelEnum.getLabel(); } } return \u0026#34;Unknown\u0026#34;; } } When we have an Enum class, method getLable() can be optimized to only just one line of implementation:\npublic String getLabel(int status) { return StatusLabelEnum.getLabelByStatus(status); } Certainly, in a actually project, this choice is not the best but is to set a key-value config table in database.\nCertainly, in an actual project, this choice is not the best but is to set a key-value config table in the database.\nIf the state is stable, Enumeration still is a simple solution.\nIf the state is stable, Enumeration remains a simple solution.\nChoice 3: Optional I\u0026rsquo;m very sure that you guys\u0026rsquo;s projects have a not-null judge. When it goes to be null, it will be returned or throw a exception:\nI\u0026rsquo;m very sure that you guys have projects where there is a non-null check. and if it\u0026rsquo;s null, it will be returned or throw an exception:\npublic int getOrderStatus(UUID id) { Order order = getOrderById(id); if (order == null) { return 1; } else { return order.getOrderStatus(); } } We can use Optional elegantly to solve this problem.\nWe can elegantly use Optional to slove this problem.\npublic int getOrderStatus(UUID id) { Order order = getOrderById(id); return Optional.ofNullable(order).map(Order::getOrderStatus).orElse(1); } The source link has 4 ways to help you to remove if-else in your code. But this article will only present you the first 3 ways, as for the reason, I would not tell you that it because I don\u0026rsquo;t want to write about it.\nThe source link mentions four methods, but this article only covers three of them. As for the reason, I won\u0026rsquo;t tell you it\u0026rsquo;s because I don\u0026rsquo;t want to write about it.\nSummary ","permalink":"https://crayonUno.github.io/posts/english/writing-01-how-to-elegantly-remove-if-else-in-your-java-code/","summary":"How to Elegantly Remove if-else in Your Java Code original link: https://medium.com/@malvin.lok/how-to-elegantly-remove-if-else-in-your-java-code-27b2393544ae practicing principles: Find a sample article of the same type that you want to improve. Translate it into Chinese. Look at the Chinese translation and write it back in English. Compare what you wrote with the sample essay, and upgrade your expression. Practice in action. Select a relative topic and write in English. My writing Sometimes, that let if-else syntax be full of your code is not a correct way to let your colleagues to understand. Sometimes, letting your code full of if-else statement is not the most effective way to help your colleagues understand it. Therefore, as a beginner, or even you are quite good at your job, still need to let your code more readable and (复杂?). Thererfore, as a beginner,","title":"01-How to Elegantly Remove if-else in Your Java Code"},{"content":" 我的另一篇关于 Git 的文章：https://crayonuno.github.io/posts/tech/git/。\n总结了平时常用的 Git 命令，和丰富的推荐学习资料。\n有两种方式设置 Git 命令别名。\n第一种找到用户主目录下的 .gitconfig 文件，将下面的内容自己复制到文件中即可。\n第二种直接通过命令行进行设置。ex： git config --global alias.co checkout（最后也是体现在 .gitconfig 文件中）。\n[alias] co = checkout cob = checkout -b br = branch brs = branch --format=\u0026#39;%(HEAD) %(color:yellow)%(refname:short)%(color:reset) - %(contents:subject) %(color:green)(%(committerdate:relative)) [%(authorname)]\u0026#39; --sort=-committerdate ci = commit cm = commit -m save = !git add -A \u0026amp;\u0026amp; git commit -m \u0026#39;chore: commit save point\u0026#39; undo = reset HEAD~1 --mixed unstage = reset HEAD -- st = status du = diff @{upstream} lg = log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit history = log --oneline --graph last = log -3 brs：用较好的可读性，列出所有分支的相关信息\ngit cm \u0026quot;在这里直接添加你想要的提交信息\u0026quot;\nsave：用定义好的提交信息，先提交工作区，再提交暂存区的所有内容，生成一次 commit。\nundo: reset 上一次提交的内容\nunstage: 暂存区回到工作区，类似撤销执行 git add .\ndu: 比较和远程分支的内容差别。一般要先 git fetch 一下\nlg：用较好的可读性，列出当前分支下的提交信息\nhistory：和 lg 差不多，列出了远程分支的 head 指向\nlast：列出最近三次提交\n参考链接：\nhttps://www.liaoxuefeng.com/wiki/896043488029600/898732837407424 https://snyk.io/blog/10-git-aliases-for-faster-and-productive-git-workflow/ ","permalink":"https://crayonUno.github.io/posts/tech/git-alias/","summary":"我的另一篇关于 Git 的文章：https://crayonuno.github.io/posts/tech/git/。 总结了平时常用的 Git 命令，和丰富的推荐学习资料。 有两种方式设置 Git 命令别名。 第一种找到用户主目录下的 .gitconfig 文件，将下面的内容自己复制到文件中即可。 第二种直接通过命令行进行设置。","title":"10个让Git更好用的命令别名(alias)"},{"content":" 在搜索资料的过程中，看到很多总结的非常完善的文章，所以还是站在巨人的肩膀上，直接引用这些内容，需要的时候检索一下就好。\n我也建议直接阅读文章中给出的这些链接去学习。\n参考资料 https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html 常用 Git 命令清单。推荐阅读 https://www.ruanyifeng.com/blog/2015/08/git-use-process.html Git 使用规范。推荐阅读 https://www.ruanyifeng.com/blog/2015/12/git-workflow.html Git 工作流程 https://www.ruanyifeng.com/blog/2014/06/git_remote.html Git 远程工作详解 https://cs.fyi/guide/git-cheatsheet Git 命令清单 https://www.atlassian.com/git/tutorials/atlassian-git-cheatsheet Git 命令清单 https://www.liaoxuefeng.com/wiki/896043488029600 Git 教程 https://learngitbranching.js.org/ 交互式学习 Git 的网址 剩下的内容就记录一些对我来说需要记住和理解的 Git 小技巧和知识点。\n命令别名 找到全局的 .gitconfig 文件，按照格式添加一下内容可以直接使用这些定义好的 git 别名。\n命令行也可以 git config --global alias.co checkout\n[alias] co = checkout cob = checkout -b br = branch brs = branch --format=\u0026#39;%(HEAD) %(color:yellow)%(refname:short)%(color:reset) - %(contents:subject) %(color:green)(%(committerdate:relative)) [%(authorname)]\u0026#39; --sort=-committerdate ci = commit cm = commit -m save = !git add -A \u0026amp;\u0026amp; git commit -m \u0026#39;chore: commit save point\u0026#39; undo = reset HEAD~1 --mixed unstage = reset HEAD -- st = status du = diff @{upstream} lg = log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit history = log --oneline --graph last = log -3 alias brs：用较好的可读性，列出所有分支的相关信息 git cm \u0026quot;在这里直接添加你想要的提交信息\u0026quot; save：用定义好的提交信息，先提交工作区，再提交暂存区的所有内容，生成一次 commit。 undo: reset 上一次提交的内容 unstage: 暂存区回到工作区，类似撤销执行 git add . du: 比较和远程分支的内容差别。一般要先 git fetch 一下 lg：用较好的可读性，列出当前分支下的提交信息 history：和 lg 差不多，列出了远程分支的 head 指向 last：列出最近三次提交 参考链接：\nhttps://www.liaoxuefeng.com/wiki/896043488029600/898732837407424 https://snyk.io/blog/10-git-aliases-for-faster-and-productive-git-workflow/ 全局配置和项目配置 Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。注意如果你通过 git config 命令设置了全局 --global 参数 配置，项目配置可能无法覆盖这些设置。\n项目根目录下是 root/.git/config 文件、用户主目录下是 /usr/.gitconfig 文件\n# 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name \u0026#34;[name]\u0026#34; $ git config [--global] user.email \u0026#34;[email address]\u0026#34; 常用命令 提交 # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] 分支 # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 远程仓库同步 # 下载远程仓库的所有变动 $ git fetch [remote] # git fetch 之后，想要本地进行合并 $ git merge origin/master # 或者 $ git rebase origin/master # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 = git fetch [origin] branch then git merge origin/branch $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all 撤销 工作区：平时的工作目录。\n暂存区：通过 git add 命令把文件/修改添加到暂存区。git commit 命令的作用是提交暂存区中的所有内容。\n$ git stash $ git stash pop rebase todo\n","permalink":"https://crayonUno.github.io/posts/tech/git/","summary":"在搜索资料的过程中，看到很多总结的非常完善的文章，所以还是站在巨人的肩膀上，直接引用这些内容，需要的时候检索一下就好。 我也建议直接阅读文章中给出的这些链接去学习。 参考资料 https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html 常用 Git 命令清单。推荐阅读 https://www.ruanyifeng.com/blog/2015/08/git-use-process.html Git 使用规范。推荐阅读 https://www.ruanyifeng.com/blog/2015/12/git-workflow.html Git 工作流程 https://www.ruanyifeng.com/blog/2014/06/git_remote.html Git 远程工作详解 https://cs.fyi/guide/git-cheatsheet Git 命令清单 https://www.atlassian.com/git/tutorials/atlassian-git-cheatsheet Git 命令清单 https://www.liaoxuefeng.com/wiki/896043488029600 Git 教程 https://learngitbranching.js.org/","title":"git tricks"},{"content":"","permalink":"https://crayonUno.github.io/posts/life/weekly-diary-01-2024-01-14/","summary":"","title":"2024-01-14 周报"},{"content":"Practicing principles 第一步，找一篇你想提高的同类型的范文。\n第二步，把它翻译成中文。\n第三步，看着中文再写回英文作文。\n第四步，把自己写的和范文比对，表达升级。\n第五步，实战练习。\n第六步，几天后，把范文的主题部分更改。\n比如把求职信，改为申请学校。\nPracticing principles find a sample article of the same type that you want to improve. translate it to Chinese version. look at the Chinese version and write it back in English. compare the two English versions, and upgrade my expression. practice in action. after a few days, change the topic and repeat the 5 steps above. upgrade Find a sample article of the same type that you want to improve.\nTranslate it into Chinese version.\nLook at the Chinese version translation and write it back in English.\nCompare the two English versions and upgrade my your expression. 祈使句，是在教别人，而不是自己。\nCompare what you wrote with the sample essay, and upgrade your expression.\nPractice in action. Practice in real situations. Practice in action 应该也可以，类似把《Netty In Action》翻译成《Netty 实战》。\nAfter a few days, change the topic and repeat the five steps above. 一般来说，小于 10 的数字要用英文单词写，而不是阿拉伯数字\nSummary In action means something is doing or active In a general way, numbers less than ten should be written in English not Arabic numerals. Be written. Compare sth with sth. ","permalink":"https://crayonUno.github.io/posts/english/writing/","summary":"Practicing principles 第一步，找一篇你想提高的同类型的范文。 第二步，把它翻译成中文。 第三步，看着中文再写回英文作文。 第四步，把自己写的和范文比对，表达升级。 第五步，实战练习。 第六步，几天后，把范文的主题部分更改。 比如把求职信，改为申请学校。 Practicing principles find a sample article of the same type that you want to improve. translate it to Chinese version. look at the Chinese version and write it back","title":"00-English Writing Exercise And Principles"},{"content":"年终总结 2023 是对自己最失望的一年，没有做好什么事情，唯一的成长就是思考了很多。最想要说的就是谢谢 Oting 和狗攀。\n2024 的目标 英语学习，提高读和写的能力。目标是可以为工作能力或者说技术能力助力。 锻炼身体和规律作息。把身体搞好。 技术能力。 算法，或者说刷题。在面试的时候不至于被算法题刷下去。 工程，可以通过代码解决实际的问题。 博客，映射平时的学习笔记。 副业：还需要再思考，1/31 号再记录一下。 总结 从 2020 开始，已经毕业了 3 年多了，始终想着要努力，但没有什么实际上的行动，事后就陷入自责，周而复始。\n2024 年会怎么样？\n","permalink":"https://crayonUno.github.io/posts/life/2023-annual-summary/","summary":"年终总结 2023 是对自己最失望的一年，没有做好什么事情，唯一的成长就是思考了很多。最想要说的就是谢谢 Oting 和狗攀。 2024 的目标 英语学习，提高读和写的能力。目标是可以为工作能力或者说技术能力助力。 锻炼身体和规律作息。把身体搞好。 技术能力。 算法，或者说刷题。在面试的时候不至于被算法题刷下去。 工程，","title":"2023 Annual Summary"},{"content":"testing\n","permalink":"https://crayonUno.github.io/posts/life/recommend-music/","summary":"testing","title":"音乐推荐"},{"content":"第一篇测试文章 封面图片 图片插入文件夹生成是否正确\rasdfasdf asdfasdf sdfsadf\nasdfsad\n从网卡接收数据说起 网卡收到传输的数据\r并将收到的数据写到内存 cpu 中断。网卡将数据写入内存后，向 cpu 发出中断信号，cpu 执行网卡中断程序。（硬件的信号优先级高）\r中断程序主要有两个功能。 将数据写到对应的 socket （与端口对应）接收缓冲区中。执行过程中对应的进程进入对应的 socket 等待队列（阻塞状态）。 socket 接收到数据后，操作系统唤醒该进程，进入工作队列（运行状态）。 服务端如何同时监视多个 socket 的数据状态？ select https://man7.org/linux/man-pages/man2/select.2.html\n假如进程 A 需要同时监控 socket1，socket2，socket3。调用 select 后，操作系统把进程 A 分别加入到这 3 个 socket 的等待队列中。\n进程A 阻塞在 select 调用上。\n当任何一个 socket 有数据后，中断程序唤醒进程，将进程 A 从所有等待队列中移除，加入到工作队列中。进程 A 被唤醒后，说明至少有一个 socket 收到了数据，遍历 socket_sets 就可知道哪个有数据。\n我们知道，如今的服务端需要同时管理的客户端连接数比较大。select 调用中需要多次遍历，需要同时监听的 socket 越多，select 调用的效率越低。也是因此，select 最多支持同时监听 1024 个 socket。\nepoll https://man7.org/linux/man-pages/man7/epoll.7.html\n流程 假如进程 A 需要同时监控 socket1，socket2，socket3。先调用 epoll_create 方法创建一个 eventpoll 对象（返回一个 fd 指向该对象），和 socket 类似，eventpoll 也有自己对应的等待队列。\n调用 epoll_ctl 添加/删除 监听的 socket（interest list（rbr））。操作系统将 eventpoll 对象添加到 socket1/2/3 的等待队列中。\n当任何一个 socket 有数据后，中断程序为 eventpoll 的 ready list（双向链表） 添加对应的 socket 引用。唤醒等待队列中的进程。\n进程 A 执行到 epoll_wait ，等待数据，如果 ready list 不为空，epoll_wait 返回，唤醒 eventpoll 等待队列中的进程。如果为空，进程 A 阻塞在 epoll_wait 调用上等待数据，操作系统会把进程 A 加入到 eventpoll 的等待队列中。\n优势 引入依赖，中心仓库没有的话可以手动下载源码 install。\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.csource\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastdfs-client-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.29-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Client\nepoll 通过一个中间层 eventpoll 对象及其对应的等待队列，进程被阻塞时只需要一次添加到等待队列中。\n通过 ready list 引用有数据的 socket 。进程被唤醒后，可以直接知道哪些 socket 有数据。\nprivate HeliosGetScoreResponse queryScores(HeliosGetScoreRequest request) { HeliosGetScoreResponse response = new HeliosGetScoreResponse(); List\u0026lt;HeliosScore\u0026gt; heliosScores = heliosService.queryScoresTimeBetween(request.getStartTime(), request.getEndTime(), request.getFilterByAppId()); if (CollectionUtils.isEmpty(heliosScores)) { return response; } Set\u0026lt;String\u0026gt; dateSet = new HashSet\u0026lt;\u0026gt;(); Map\u0026lt;String, List\u0026lt;HeliosScore\u0026gt;\u0026gt; groupByAppIdHeliosScores = heliosScores.stream().collect(Collectors.groupingBy(HeliosScore::getAppId)); for (List\u0026lt;HeliosScore\u0026gt; value : groupByAppIdHeliosScores.values()) { value.sort(Comparator.comparing(HeliosScore::getTimeFrom)); HeliosGetScoreResponse.Score score = new HeliosGetScoreResponse.Score(); score.setNamespace(value.get(0).getNamespace()); score.setAppId(value.get(0).getAppId()); for (HeliosScore heliosScore : value) { List\u0026lt;HeliosScore\u0026gt; splitHeliosScores = heliosScore.split(); for (HeliosScore splitHeliosScore : splitHeliosScores) { if (splitHeliosScore.getTimeFrom().compareTo(request.getStartTime()) \u0026lt; 0) { continue; } if (splitHeliosScore.getTimeFrom().compareTo(request.getEndTime()) \u0026gt; 0) { break; } dateSet.add(DateUtils.yyyyMMddHHmm.formatDate(splitHeliosScore.getTimeFrom())); if (splitHeliosScore.getScores() == null) { splitHeliosScore.setScores(\u0026#34;100\u0026#34;); log.error(\u0026#34;查询时发现数据缺失: {}\u0026#34;, heliosScore); } score.add(Math.max(0, Integer.parseInt(splitHeliosScore.getScores())), null); } } response.getValues().add(score); } response.setDates(new ArrayList\u0026lt;\u0026gt;(dateSet).stream().sorted().collect(Collectors.toList())); return response; } 相关链接 https://zhuanlan.zhihu.com/p/63179839 https://man7.org/linux/man-pages/man7/epoll.7.html https://man7.org/linux/man-pages/man2/select.2.html 上面提到的直接引用 socket，操作系统中间都有一些间接结构，并非直接引用。 根据项目的描述，FastDFS 是一个开源的高性能分布式文件系统。 它的主要功能包括：文件存储，文件同步和文件访问，以及高容量和负载平衡。\nFastDFS 框架设计思路 FastDFS 文件系统总体上划分为三个部分，Client，Tracker Server 和 Storage Server。\nStorage Server ，存储服务器，负责存 ","permalink":"https://crayonUno.github.io/posts/tech/my-test2/","summary":"\u003ch1 id=\"第一篇测试文章\"\u003e第一篇测试文章\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e封面图片\u003c/li\u003e\n\u003cli\u003e图片插入文件夹生成是否正确\u003cimg loading=\"lazy\" src=\"1.png\" alt=\"1\"  /\u003e\r\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"asdfasdf\"\u003easdfasdf\u003c/h2\u003e\n\u003ch3 id=\"asdfasdf-1\"\u003easdfasdf\u003c/h3\u003e\n\u003cp\u003esdfsadf\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/crayonUno/picture/main/blog/6c3e6b13gy1hh900ta17lj20fo0jlq3i.jpg\" alt=\"6c3e6b13gy1hh900ta17lj20fo0jlq3i\"  /\u003e\r\n\u003c/p\u003e\n\u003cp\u003easdfsad\u003c/p\u003e\n\u003ch2 id=\"从网卡接收数据说起\"\u003e从网卡接收数据说起\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e网卡收到传输的数据\u003cimg loading=\"lazy\" src=\"C:/Users/Crayon/Desktop/avatar-originnal.jpg\" alt=\"avatar-originnal\"  /\u003e\r\n\u003c/li\u003e\n\u003cli\u003e并将收到的数据写到内存\u003c/li\u003e\n\u003c/ol\u003e","title":"Blog functional test"},{"content":"常用操作 本地预览调试 hugo server -D #本地启动预览 hugo -F --cleanDestinationDir #重新生成 public 文件夹下的内容 hugo new /posts/[folderName]/[artileName].md # 生成文章到 content/posts/folderName下 图片引用方式 在文章里面使用本地图片的方式： 比如我在content/posts/tech/下有一篇文章叫做 golang_base.md，那么在和该文章同一目录下新建一个文件夹叫做 golang_base，里面放图片如叫做 picture.png 的图片，那么在golang_base.md里面调用的时候直接引用文件名即可。\n这种方式有一个问题是在本地编辑器中没有方法实时预览到引用的图片。研究一番后，最后先用 PicGo + Github 搭一个免费的图床来使用。这样的话设置好之后，直接将图片插入到 Typora 就可以自动上传并引用图片的 URL 进行访问。\n个人常用命令 hugo new /posts/life/weekly-diary-xx-2024-01-xx.md #周报命名格式 TODO github CNAME 文件会被本地重新生成的 public 文件夹内容覆盖 参考链接 https://www.sulvblog.cn/posts/blog/build_hugo/ 搭建教程 https://github.com/xyming108/sulv-hugo-papermod 博客源码 https://www.sulvblog.cn/ 教程和源码作者博客地址 ","permalink":"https://crayonUno.github.io/posts/blog/create-blog-operations/","summary":"常用操作 本地预览调试 hugo server -D #本地启动预览 hugo -F --cleanDestinationDir #重新生成 public 文件夹下的内容 hugo new /posts/[folderName]/[artileName].md # 生成文章到 content/posts/folderName下 图片引用方式 在文章里面使用本地图片的方式： 比如我在content/posts/tech/下有一篇文章叫做 golang_base.md，那么在","title":"博客常用操作"},{"content":"\rSulv\u0026#39;s Blog\r一个记录技术、阅读、生活的博客\r👉友链格式\r名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求\r秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n👉Hugo博客交流群\r787018782\n","permalink":"https://crayonUno.github.io/links/","summary":"Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内 👉Hugo博客交流群 787018782","title":"🤝友链"},{"content":"关于我\nEmail fanghx024@foxmail.com 职业: 程序员 爱好: 🏀 关于这个博客\n都是基于以下这个仓库和教程搭建的。\nhttps://www.sulvblog.cn/posts/blog/build_hugo/ 建站教程 https://github.com/xyming108/sulv-hugo-papermod 代码仓库 ","permalink":"https://crayonUno.github.io/about/","summary":"关于我 Email fanghx024@foxmail.com 职业: 程序员 爱好: 🏀 关于这个博客 都是基于以下这个仓库和教程搭建的。 https://www.sulvblog.cn/posts/blog/build_hugo/ 建站教程 https://github.com/xyming108/sulv-hugo-papermod 代码仓库","title":"🙋🏻‍♂️关于"}]