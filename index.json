[{"content":"常用操作 本地预览调试 hugo server -D #本地启动预览 hugo -F --cleanDestinationDir #重新生成 public 文件夹下的内容 hugo new /posts/[folderName]/[artileName].md # 生成文章到 content/posts/folderName下 图片引用方式 在文章里面使用本地图片的方式： 比如我在content/posts/tech/下有一篇文章叫做 golang_base.md，那么在和该文章同一目录下新建一个文件夹叫做 golang_base，里面放图片如叫做 picture.png 的图片，那么在golang_base.md里面调用的时候直接引用文件名即可。\n这种方式有一个问题是在本地编辑器中没有方法实时预览到引用的图片。研究一番后，最后先用 PicGo + Github 搭一个免费的图床来使用。这样的话设置好之后，直接将图片插入到 Typora 就可以自动上传并引用图片的 URL 进行访问。\n参考链接 https://www.sulvblog.cn/posts/blog/build_hugo/ 搭建教程 https://github.com/xyming108/sulv-hugo-papermod 博客源码 https://www.sulvblog.cn/ 教程和源码作者博客地址 ","permalink":"https://crayonUno.github.io/posts/blog/hugo-papermod-operations-records/","summary":"常用操作 本地预览调试 hugo server -D #本地启动预览 hugo -F --cleanDestinationDir #重新生成 public 文件夹下的内容 hugo new /posts/[folderName]/[artileName].md # 生成文章到 content/posts/folderName下 图片引用方式 在文章里面使用本地图片的方式： 比如我在content/posts/tech/下有一篇文章叫做 golang_base.md，那么在","title":"博客常用操作"},{"content":"testing\n","permalink":"https://crayonUno.github.io/posts/life/recommend-music/","summary":"testing","title":"音乐推荐"},{"content":"第一篇测试文章 封面图片 图片插入文件夹生成是否正确\rasdfasdf asdfasdf sdfsadf\nasdfsad\n从网卡接收数据说起 网卡收到传输的数据\r并将收到的数据写到内存 cpu 中断。网卡将数据写入内存后，向 cpu 发出中断信号，cpu 执行网卡中断程序。（硬件的信号优先级高）\r中断程序主要有两个功能。 将数据写到对应的 socket （与端口对应）接收缓冲区中。执行过程中对应的进程进入对应的 socket 等待队列（阻塞状态）。 socket 接收到数据后，操作系统唤醒该进程，进入工作队列（运行状态）。 服务端如何同时监视多个 socket 的数据状态？ select https://man7.org/linux/man-pages/man2/select.2.html\n假如进程 A 需要同时监控 socket1，socket2，socket3。调用 select 后，操作系统把进程 A 分别加入到这 3 个 socket 的等待队列中。\n进程A 阻塞在 select 调用上。\n当任何一个 socket 有数据后，中断程序唤醒进程，将进程 A 从所有等待队列中移除，加入到工作队列中。进程 A 被唤醒后，说明至少有一个 socket 收到了数据，遍历 socket_sets 就可知道哪个有数据。\n我们知道，如今的服务端需要同时管理的客户端连接数比较大。select 调用中需要多次遍历，需要同时监听的 socket 越多，select 调用的效率越低。也是因此，select 最多支持同时监听 1024 个 socket。\nepoll https://man7.org/linux/man-pages/man7/epoll.7.html\n流程 假如进程 A 需要同时监控 socket1，socket2，socket3。先调用 epoll_create 方法创建一个 eventpoll 对象（返回一个 fd 指向该对象），和 socket 类似，eventpoll 也有自己对应的等待队列。\n调用 epoll_ctl 添加/删除 监听的 socket（interest list（rbr））。操作系统将 eventpoll 对象添加到 socket1/2/3 的等待队列中。\n当任何一个 socket 有数据后，中断程序为 eventpoll 的 ready list（双向链表） 添加对应的 socket 引用。唤醒等待队列中的进程。\n进程 A 执行到 epoll_wait ，等待数据，如果 ready list 不为空，epoll_wait 返回，唤醒 eventpoll 等待队列中的进程。如果为空，进程 A 阻塞在 epoll_wait 调用上等待数据，操作系统会把进程 A 加入到 eventpoll 的等待队列中。\n优势 引入依赖，中心仓库没有的话可以手动下载源码 install。\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.csource\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastdfs-client-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.29-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Client\nepoll 通过一个中间层 eventpoll 对象及其对应的等待队列，进程被阻塞时只需要一次添加到等待队列中。\n通过 ready list 引用有数据的 socket 。进程被唤醒后，可以直接知道哪些 socket 有数据。\nprivate HeliosGetScoreResponse queryScores(HeliosGetScoreRequest request) { HeliosGetScoreResponse response = new HeliosGetScoreResponse(); List\u0026lt;HeliosScore\u0026gt; heliosScores = heliosService.queryScoresTimeBetween(request.getStartTime(), request.getEndTime(), request.getFilterByAppId()); if (CollectionUtils.isEmpty(heliosScores)) { return response; } Set\u0026lt;String\u0026gt; dateSet = new HashSet\u0026lt;\u0026gt;(); Map\u0026lt;String, List\u0026lt;HeliosScore\u0026gt;\u0026gt; groupByAppIdHeliosScores = heliosScores.stream().collect(Collectors.groupingBy(HeliosScore::getAppId)); for (List\u0026lt;HeliosScore\u0026gt; value : groupByAppIdHeliosScores.values()) { value.sort(Comparator.comparing(HeliosScore::getTimeFrom)); HeliosGetScoreResponse.Score score = new HeliosGetScoreResponse.Score(); score.setNamespace(value.get(0).getNamespace()); score.setAppId(value.get(0).getAppId()); for (HeliosScore heliosScore : value) { List\u0026lt;HeliosScore\u0026gt; splitHeliosScores = heliosScore.split(); for (HeliosScore splitHeliosScore : splitHeliosScores) { if (splitHeliosScore.getTimeFrom().compareTo(request.getStartTime()) \u0026lt; 0) { continue; } if (splitHeliosScore.getTimeFrom().compareTo(request.getEndTime()) \u0026gt; 0) { break; } dateSet.add(DateUtils.yyyyMMddHHmm.formatDate(splitHeliosScore.getTimeFrom())); if (splitHeliosScore.getScores() == null) { splitHeliosScore.setScores(\u0026#34;100\u0026#34;); log.error(\u0026#34;查询时发现数据缺失: {}\u0026#34;, heliosScore); } score.add(Math.max(0, Integer.parseInt(splitHeliosScore.getScores())), null); } } response.getValues().add(score); } response.setDates(new ArrayList\u0026lt;\u0026gt;(dateSet).stream().sorted().collect(Collectors.toList())); return response; } 相关链接 https://zhuanlan.zhihu.com/p/63179839 https://man7.org/linux/man-pages/man7/epoll.7.html https://man7.org/linux/man-pages/man2/select.2.html 上面提到的直接引用 socket，操作系统中间都有一些间接结构，并非直接引用。 根据项目的描述，FastDFS 是一个开源的高性能分布式文件系统。 它的主要功能包括：文件存储，文件同步和文件访问，以及高容量和负载平衡。\nFastDFS 框架设计思路 FastDFS 文件系统总体上划分为三个部分，Client，Tracker Server 和 Storage Server。\nStorage Server ，存储服务器，负责存 ","permalink":"https://crayonUno.github.io/posts/tech/my-test2/","summary":"\u003ch1 id=\"第一篇测试文章\"\u003e第一篇测试文章\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e封面图片\u003c/li\u003e\n\u003cli\u003e图片插入文件夹生成是否正确\u003cimg loading=\"lazy\" src=\"1.png\" alt=\"1\"  /\u003e\r\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"asdfasdf\"\u003easdfasdf\u003c/h2\u003e\n\u003ch3 id=\"asdfasdf-1\"\u003easdfasdf\u003c/h3\u003e\n\u003cp\u003esdfsadf\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/crayonUno/picture/main/blog/6c3e6b13gy1hh900ta17lj20fo0jlq3i.jpg\" alt=\"6c3e6b13gy1hh900ta17lj20fo0jlq3i\"  /\u003e\r\n\u003c/p\u003e\n\u003cp\u003easdfsad\u003c/p\u003e\n\u003ch2 id=\"从网卡接收数据说起\"\u003e从网卡接收数据说起\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e网卡收到传输的数据\u003cimg loading=\"lazy\" src=\"C:/Users/Crayon/Desktop/avatar-originnal.jpg\" alt=\"avatar-originnal\"  /\u003e\r\n\u003c/li\u003e\n\u003cli\u003e并将收到的数据写到内存\u003c/li\u003e\n\u003c/ol\u003e","title":"Blog functional test"},{"content":"\rSulv\u0026#39;s Blog\r一个记录技术、阅读、生活的博客\r👉友链格式\r名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求\r秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n👉Hugo博客交流群\r787018782\n","permalink":"https://crayonUno.github.io/links/","summary":"Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内 👉Hugo博客交流群 787018782","title":"🤝友链"},{"content":"关于我\nEmail fanghx024@foxmail.com 职业: 程序员 爱好: 🏀 关于这个博客\n\u0026hellip;\n","permalink":"https://crayonUno.github.io/about/","summary":"关于我 Email fanghx024@foxmail.com 职业: 程序员 爱好: 🏀 关于这个博客 \u0026hellip;","title":"🙋🏻‍♂️关于"}]