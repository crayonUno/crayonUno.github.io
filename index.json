[{"content":"第一篇测试文章 封面图片 图片插入文件夹生成是否正确\rasdfasdf asdfasdf sdfsadf\nasdfsad\n从网卡接收数据说起 网卡收到传输的数据 并将收到的数据写到内存 cpu 中断。网卡将数据写入内存后，向 cpu 发出中断信号，cpu 执行网卡中断程序。（硬件的信号优先级高） 中断程序主要有两个功能。 将数据写到对应的 socket （与端口对应）接收缓冲区中。执行过程中对应的进程进入对应的 socket 等待队列（阻塞状态）。 socket 接收到数据后，操作系统唤醒该进程，进入工作队列（运行状态）。 服务端如何同时监视多个 socket 的数据状态？ select https://man7.org/linux/man-pages/man2/select.2.html\n假如进程 A 需要同时监控 socket1，socket2，socket3。调用 select 后，操作系统把进程 A 分别加入到这 3 个 socket 的等待队列中。\n进程A 阻塞在 select 调用上。\n当任何一个 socket 有数据后，中断程序唤醒进程，将进程 A 从所有等待队列中移除，加入到工作队列中。进程 A 被唤醒后，说明至少有一个 socket 收到了数据，遍历 socket_sets 就可知道哪个有数据。\n我们知道，如今的服务端需要同时管理的客户端连接数比较大。select 调用中需要多次遍历，需要同时监听的 socket 越多，select 调用的效率越低。也是因此，select 最多支持同时监听 1024 个 socket。\nepoll https://man7.org/linux/man-pages/man7/epoll.7.html\n流程 假如进程 A 需要同时监控 socket1，socket2，socket3。先调用 epoll_create 方法创建一个 eventpoll 对象（返回一个 fd 指向该对象），和 socket 类似，eventpoll 也有自己对应的等待队列。\n调用 epoll_ctl 添加/删除 监听的 socket（interest list（rbr））。操作系统将 eventpoll 对象添加到 socket1/2/3 的等待队列中。\n当任何一个 socket 有数据后，中断程序为 eventpoll 的 ready list（双向链表） 添加对应的 socket 引用。唤醒等待队列中的进程。\n进程 A 执行到 epoll_wait ，等待数据，如果 ready list 不为空，epoll_wait 返回，唤醒 eventpoll 等待队列中的进程。如果为空，进程 A 阻塞在 epoll_wait 调用上等待数据，操作系统会把进程 A 加入到 eventpoll 的等待队列中。\n优势 引入依赖，中心仓库没有的话可以手动下载源码 install。\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.csource\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastdfs-client-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.29-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Client\nepoll 通过一个中间层 eventpoll 对象及其对应的等待队列，进程被阻塞时只需要一次添加到等待队列中。\n通过 ready list 引用有数据的 socket 。进程被唤醒后，可以直接知道哪些 socket 有数据。\nprivate HeliosGetScoreResponse queryScores(HeliosGetScoreRequest request) { HeliosGetScoreResponse response = new HeliosGetScoreResponse(); List\u0026lt;HeliosScore\u0026gt; heliosScores = heliosService.queryScoresTimeBetween(request.getStartTime(), request.getEndTime(), request.getFilterByAppId()); if (CollectionUtils.isEmpty(heliosScores)) { return response; } Set\u0026lt;String\u0026gt; dateSet = new HashSet\u0026lt;\u0026gt;(); Map\u0026lt;String, List\u0026lt;HeliosScore\u0026gt;\u0026gt; groupByAppIdHeliosScores = heliosScores.stream().collect(Collectors.groupingBy(HeliosScore::getAppId)); for (List\u0026lt;HeliosScore\u0026gt; value : groupByAppIdHeliosScores.values()) { value.sort(Comparator.comparing(HeliosScore::getTimeFrom)); HeliosGetScoreResponse.Score score = new HeliosGetScoreResponse.Score(); score.setNamespace(value.get(0).getNamespace()); score.setAppId(value.get(0).getAppId()); for (HeliosScore heliosScore : value) { List\u0026lt;HeliosScore\u0026gt; splitHeliosScores = heliosScore.split(); for (HeliosScore splitHeliosScore : splitHeliosScores) { if (splitHeliosScore.getTimeFrom().compareTo(request.getStartTime()) \u0026lt; 0) { continue; } if (splitHeliosScore.getTimeFrom().compareTo(request.getEndTime()) \u0026gt; 0) { break; } dateSet.add(DateUtils.yyyyMMddHHmm.formatDate(splitHeliosScore.getTimeFrom())); if (splitHeliosScore.getScores() == null) { splitHeliosScore.setScores(\u0026#34;100\u0026#34;); log.error(\u0026#34;查询时发现数据缺失: {}\u0026#34;, heliosScore); } score.add(Math.max(0, Integer.parseInt(splitHeliosScore.getScores())), null); } } response.getValues().add(score); } response.setDates(new ArrayList\u0026lt;\u0026gt;(dateSet).stream().sorted().collect(Collectors.toList())); return response; } 相关链接 https://zhuanlan.zhihu.com/p/63179839 https://man7.org/linux/man-pages/man7/epoll.7.html https://man7.org/linux/man-pages/man2/select.2.html 上面提到的直接引用 socket，操作系统中间都有一些间接结构，并非直接引用。 根据项目的描述，FastDFS 是一个开源的高性能分布式文件系统。 它的主要功能包括：文件存储，文件同步和文件访问，以及高容量和负载平衡。\nFastDFS 框架设计思路 FastDFS 文件系统总体上划分为三个部分，Client，Tracker Server 和 Storage Server。\nStorage Server ，存储服务器，负责存 ","permalink":"https://xyming108.github.io/posts/tech/my-test2/","summary":"\u003ch1 id=\"第一篇测试文章\"\u003e第一篇测试文章\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e封面图片\u003c/li\u003e\n\u003cli\u003e图片插入文件夹生成是否正确\u003cimg loading=\"lazy\" src=\"1.png\" alt=\"1\"  /\u003e\r\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"asdfasdf\"\u003easdfasdf\u003c/h2\u003e\n\u003ch3 id=\"asdfasdf-1\"\u003easdfasdf\u003c/h3\u003e\n\u003cp\u003esdfsadf\u003c/p\u003e\n\u003cp\u003easdfsad\u003c/p\u003e\n\u003ch2 id=\"从网卡接收数据说起\"\u003e从网卡接收数据说起\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e网卡收到传输的数据\u003c/li\u003e\n\u003cli\u003e并将收到的数据写到内存\u003c/li\u003e\n\u003c/ol\u003e","title":"My Test2"},{"content":"","permalink":"https://xyming108.github.io/posts/tech/my-test/","summary":"","title":"My Test"},{"content":"1. 介绍 scan命令的作用和keys *的作用类似，主要用于查找redis中的键，但是在正式的生产环境中一般不会直接使用keys *这个命令，因为他会返回所有的键，如果键的数量很多会导致查询时间很长，进而导致服务器阻塞，所以需要scan来进行更细致的查找\nscan总共有这几种命令：scan、sscan、hscan、zscan，分别用于迭代数据库中的：数据库中所有键、集合键、哈希键、有序集合键，命令具体结构如下：\nscan cursor [MATCH pattern] [COUNT count] [TYPE type] sscan key cursor [MATCH pattern] [COUNT count] hscan key cursor [MATCH pattern] [COUNT count] zscan key cursor [MATCH pattern] [COUNT count] 2. scan scan cursor [MATCH pattern] [COUNT count] [TYPE type]，cursor表示游标，指查询开始的位置，count默认为10，查询完后会返回下一个开始的游标，当返回0的时候表示所有键查询完了\n127.0.0.1:6379[2]\u0026gt; scan 0 1) \u0026#34;3\u0026#34; 2) 1) \u0026#34;mystring\u0026#34; 2) \u0026#34;myzadd\u0026#34; 3) \u0026#34;myhset\u0026#34; 4) \u0026#34;mylist\u0026#34; 5) \u0026#34;myset2\u0026#34; 6) \u0026#34;myset1\u0026#34; 7) \u0026#34;mystring1\u0026#34; 8) \u0026#34;mystring3\u0026#34; 9) \u0026#34;mystring4\u0026#34; 10) \u0026#34;myset\u0026#34; 127.0.0.1:6379[2]\u0026gt; scan 3 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;myzadd1\u0026#34; 2) \u0026#34;mystring2\u0026#34; 3) \u0026#34;mylist2\u0026#34; 4) \u0026#34;myhset1\u0026#34; 5) \u0026#34;mylist1\u0026#34; MATCH可以采用模糊匹配找出自己想要查找的键，这里的逻辑是先查出20个，再匹配，而不是先匹配再查询，这里加上count 20是因为默认查出的10个数中可能不能包含所有的相关项，所以把范围扩大到查20个，我这里测试的键总共有15个\n127.0.0.1:6379[2]\u0026gt; scan 0 match mylist* count 20 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;mylist\u0026#34; 2) \u0026#34;mylist2\u0026#34; 3) \u0026#34;mylist1\u0026#34; TYPE可以根据具体的结构类型来匹配该类型的键\n127.0.0.1:6379[2]\u0026gt; scan 0 count 20 type list 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;mylist\u0026#34; 2) \u0026#34;mylist2\u0026#34; 3) \u0026#34;mylist1\u0026#34; 3. sscan sscan key cursor [MATCH pattern] [COUNT count]，sscan的第一个参数总是集合类型的key\n127.0.0.1:6379[2]\u0026gt; sadd myset1 a b c d (integer) 4 127.0.0.1:6379[2]\u0026gt; smembers myset1 1) \u0026#34;d\u0026#34; 2) \u0026#34;a\u0026#34; 3) \u0026#34;c\u0026#34; 4) \u0026#34;b\u0026#34; 127.0.0.1:6379[2]\u0026gt; sscan myset1 0 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;d\u0026#34; 2) \u0026#34;c\u0026#34; 3) \u0026#34;b\u0026#34; 4) \u0026#34;a\u0026#34; 127.0.0.1:6379[2]\u0026gt; sscan myset1 0 match a 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;a\u0026#34; 4. hscan hscan key cursor [MATCH pattern] [COUNT count]，sscan的第一个参数总是哈希类型的key\n127.0.0.1:6379[2]\u0026gt; hset myhset1 kk1 vv1 kk2 vv2 kk3 vv3 (integer) 3 127.0.0.1:6379[2]\u0026gt; hgetall myhset1 1) \u0026#34;kk1\u0026#34; 2) \u0026#34;vv1\u0026#34; 3) \u0026#34;kk2\u0026#34; 4) \u0026#34;vv2\u0026#34; 5) \u0026#34;kk3\u0026#34; 6) \u0026#34;vv3\u0026#34; 127.0.0.1:6379[2]\u0026gt; hscan myhset1 0 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;kk1\u0026#34; 2) \u0026#34;vv1\u0026#34; 3) \u0026#34;kk2\u0026#34; 4) \u0026#34;vv2\u0026#34; 5) \u0026#34;kk3\u0026#34; 6) \u0026#34;vv3\u0026#34; 5. zscan zscan key cursor [MATCH pattern] [COUNT count]，sscan的第一个参数总是有序集合类型的key\n127.0.0.1:6379[2]\u0026gt; zadd myzadd1 1 zz1 2 zz2 3 zz3 (integer) 3 127.0.0.1:6379[2]\u0026gt; zrange myzadd1 0 -1 withscores 1) \u0026#34;zz1\u0026#34; 2) \u0026#34;1\u0026#34; 3) \u0026#34;zz2\u0026#34; 4) \u0026#34;2\u0026#34; 5) \u0026#34;zz3\u0026#34; 6) \u0026#34;3\u0026#34; 127.0.0.1:6379[2]\u0026gt; zscan myzadd1 0 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;zz1\u0026#34; 2) \u0026#34;1\u0026#34; 3) \u0026#34;zz2\u0026#34; 4) \u0026#34;2\u0026#34; 5) \u0026#34;zz3\u0026#34; 6) \u0026#34;3\u0026#34; ","permalink":"https://xyming108.github.io/posts/tech/tech1/","summary":"1. 介绍 scan命令的作用和keys *的作用类似，主要用于查找redis中的键，但是在正式的生产环境中一般不会直接使用keys *这个命令，因为他会返回所有的键，如果键的数量很多会导致查询时间很长，进而导致服务器阻塞，所以需要scan来进行更细致的查找 scan总共有这几种命令：sca","title":"Redis scan命令学习"},{"content":"","permalink":"https://xyming108.github.io/posts/blog/blog/","summary":"","title":"Blog"},{"content":"阿迪达斯地方 是的发顺丰\n是的发\n","permalink":"https://xyming108.github.io/posts/recommend/life/","summary":"阿迪达斯地方 是的发顺丰 是的发","title":"推荐内容"},{"content":"","permalink":"https://xyming108.github.io/posts/read/read/","summary":"","title":"Read"},{"content":"\u0026lt;div\u0026gt; 科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 \u0026lt;/div\u0026gt; ","permalink":"https://xyming108.github.io/posts/tech/tech/","summary":"\u0026lt;div\u0026gt; 科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代","title":"Tech"},{"content":"\rSulv\u0026#39;s Blog\r一个记录技术、阅读、生活的博客\r👉友链格式\r名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求\r秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n👉Hugo博客交流群\r787018782\n","permalink":"https://xyming108.github.io/links/","summary":"Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内 👉Hugo博客交流群 787018782","title":"🤝友链"},{"content":"关于我\nEmail hexin.in@qq.com 英文名: Crayon 职业: 程序员 爱好: 🏀 关于这个博客\n基于 Sulv\u0026rsquo;s Blog 的博客模板搭建，谢谢 Kevin Xu。\nSulv\u0026rsquo;s Blog 地址：https://www.sulvblog.cn/\n博客仓库源码：博客源码:\thttps://github.com/xyming108/sulv-hugo-papermod\n","permalink":"https://xyming108.github.io/about/","summary":"关于我 Email hexin.in@qq.com 英文名: Crayon 职业: 程序员 爱好: 🏀 关于这个博客 基于 Sulv\u0026rsquo;s Blog 的博客模板搭建，谢谢 Kevin Xu。 Sulv\u0026rsquo;s Blog 地址：https://www.sulvblog.cn/ 博客仓库源码：博客源码: https://github.com/xyming108/sulv-hugo-papermod","title":"🙋🏻‍♂️关于"}]